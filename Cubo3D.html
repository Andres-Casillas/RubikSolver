<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>Cubo Rubik 3√ó3 ‚Äî Three.js</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-family: inherit;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 8px;
        max-width: 400px;
      }
      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        align-items: center;
      }
      .control-btn {
        background: #4CAF50;
        border: none;
        color: white;
        padding: 10px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }
      .control-btn:hover {
        background: #45a049;
      }
      .control-btn:disabled {
        background: #666;
        cursor: not-allowed;
      }
      .step-info {
        color: #fff;
        margin: 5px 0;
        font-size: 12px;
      }
      #speed-control {
        margin-left: 15px;
        color: #fff;
      }
      #speed-slider {
        margin-left: 5px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <div>üéÆ <strong>Cubo Rubik 3√ó3 Interactivo</strong></div>
      <div class="step-info" id="step-info">Listo para comenzar</div>
      <div class="step-info" id="move-description">Presiona un bot√≥n para comenzar</div>
    </div>
    
    <div id="controls">
      <button class="control-btn" id="prev-btn" disabled>‚¨ÖÔ∏è Anterior</button>
      <button class="control-btn" id="next-btn" disabled>Siguiente ‚û°Ô∏è</button>
      <button class="control-btn" id="reset-btn">üîÑ Reiniciar</button>
      <button class="control-btn" id="pause-btn" disabled>‚è∏Ô∏è Pausar</button>
      <button class="control-btn" id="load-sequence-btn">üìù Cargar Secuencia</button>
      <button class="control-btn" id="solve-server-btn">üß† Resolver desde Servidor</button>
      
      <div id="speed-control">
        <label>Velocidad: <input type="range" id="speed-slider" min="100" max="1000" value="300" step="50"></label>
        <span id="speed-value">300ms</span>
      </div>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
          "three/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/controls/OrbitControls.js";

      // ‚Ü™ Configuraci√≥n del render, c√°mara y escena
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a); // Fondo gris oscuro
      
      const camera = new THREE.PerspectiveCamera(
        45,
        innerWidth / innerHeight,
        0.1,
        100
      );
      camera.position.set(4, 4, 6);
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      document.body.appendChild(renderer.domElement);
      
      // Agregar iluminaci√≥n
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Agregar plano de fondo para sombras
      const planeGeometry = new THREE.PlaneGeometry(20, 20);
      const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x808080, transparent: true, opacity: 0.3 });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.rotation.x = -Math.PI / 2;
      plane.position.y = -2;
      plane.receiveShadow = true;
      scene.add(plane);
      
      window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
      new OrbitControls(camera, renderer.domElement);

      // ‚Ü™ Par√°metros ajustables
      const cubieSize = 0.95;
      const gap = 0.1;
      let animationDuration = 300; // ms por movimiento (configurable)

      // ‚Ü™ Funci√≥n de easing para animaciones m√°s naturales
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      // ‚Ü™ Funci√≥n para comparaci√≥n con tolerancia (soluciona problemas de redondeo)
      const epsilon = 0.01;
      const isClose = (a, b) => Math.abs(a - b) < epsilon;

      // ‚Ü™ Funci√≥n para obtener color seg√∫n posici√≥n con tolerancia
      const getColorForPosition = (x, y, z, faceIndex) => {
        // BoxGeometry en Three.js: 0: +X, 1: -X, 2: +Y, 3: -Y, 4: +Z, 5: -Z
        switch (faceIndex) {
          case 0: return isClose(x, 1) ? COLORS.R : 0x222222;   // Right (+X)
          case 1: return isClose(x, -1) ? COLORS.L : 0x222222;  // Left (-X)
          case 2: return isClose(y, 1) ? COLORS.U : 0x222222;   // Top (+Y)
          case 3: return isClose(y, -1) ? COLORS.D : 0x222222;  // Bottom (-Y)
          case 4: return isClose(z, 1) ? COLORS.F : 0x222222;   // Front (+Z)
          case 5: return isClose(z, -1) ? COLORS.B : 0x222222;  // Back (-Z)
          default: return 0x222222;
        }
      };

      // ‚Ü™ Colores est√°ndares Rubik (m√°s realistas)
      const COLORS = {
        U: 0xffd700,  // Amarillo dorado
        D: 0xffffff,  // Blanco
        F: 0x00aa00,  // Verde
        B: 0x0066cc,  // Azul
        L: 0xff6600,  // Naranja
        R: 0xcc0000,  // Rojo
      };

      // ‚Ü™ Mapeo de colores de matriz del servidor a colores 3D
      const COLOR_MAP = {
        'W': 0xffffff,  // Blanco
        'R': 0xcc0000,  // Rojo
        'Y': 0xffd700,  // Amarillo
        'O': 0xff6600,  // Naranja
        'G': 0x00aa00,  // Verde
        'B': 0x0066cc,  // Azul
      };

      // ‚Ü™ Funci√≥n para aplicar colores de matriz al cubo 3D
      function aplicarColoresDeMatriz(matriz) {
        console.log(' Aplicando colores de matriz al cubo 3D:', matriz);
        
        // Estructura de la matriz del servidor:
        // 0: Cara superior (U) - Y = 1
        // 1: Cara frontal (F) - Z = 1  
        // 2: Cara inferior (D) - Y = -1
        // 3: Cara trasera (B) - Z = -1
        // 4: Cara izquierda (L) - X = -1
        // 5: Cara derecha (R) - X = 1
        
        const carasMatriz = {
          U: matriz[0], // Superior
          F: matriz[1], // Frontal
          D: matriz[2], // Inferior
          B: matriz[3], // Trasera
          L: matriz[4], // Izquierda
          R: matriz[5]  // Derecha
        };
        
        // Aplicar colores a cada cubie
        cubies.forEach(cubie => {
          const [x, y, z] = cubie.userData.cubePos;
          
          // Para cada cara del cubie, determinar el color basado en la matriz
          cubie.material.forEach((material, faceIndex) => {
            let color = 0x222222; // Color por defecto (gris para caras internas)
            
            // BoxGeometry faces: 0: +X(R), 1: -X(L), 2: +Y(U), 3: -Y(D), 4: +Z(F), 5: -Z(B)
            switch (faceIndex) {
              case 0: // Cara derecha (+X)
                if (isClose(x, 1)) {
                  const [row, col] = obtenerPosicionEnCara(y, z, 'R');
                  color = COLOR_MAP[carasMatriz.R[row][col]] || 0x222222;
                }
                break;
              case 1: // Cara izquierda (-X)
                if (isClose(x, -1)) {
                  const [row, col] = obtenerPosicionEnCara(y, z, 'L');
                  color = COLOR_MAP[carasMatriz.L[row][col]] || 0x222222;
                }
                break;
              case 2: // Cara superior (+Y)
                if (isClose(y, 1)) {
                  const [row, col] = obtenerPosicionEnCara(z, x, 'U');
                  color = COLOR_MAP[carasMatriz.U[row][col]] || 0x222222;
                }
                break;
              case 3: // Cara inferior (-Y)
                if (isClose(y, -1)) {
                  const [row, col] = obtenerPosicionEnCara(z, x, 'D');
                  color = COLOR_MAP[carasMatriz.D[row][col]] || 0x222222;
                }
                break;
              case 4: // Cara frontal (+Z)
                if (isClose(z, 1)) {
                  const [row, col] = obtenerPosicionEnCara(y, x, 'F');
                  color = COLOR_MAP[carasMatriz.F[row][col]] || 0x222222;
                }
                break;
              case 5: // Cara trasera (-Z)
                if (isClose(z, -1)) {
                  const [row, col] = obtenerPosicionEnCara(y, x, 'B');
                  color = COLOR_MAP[carasMatriz.B[row][col]] || 0x222222;
                }
                break;
            }
            
            material.color.setHex(color);
          });
        });
        
        console.log('‚úÖ Colores aplicados correctamente al cubo 3D');
      }

      // ‚Ü™ Funci√≥n para convertir coordenadas 3D a posici√≥n en matriz de cara
      function obtenerPosicionEnCara(coord1, coord2, cara) {
        // Convertir coordenadas de cubie (-1, 0, 1) a √≠ndices de matriz (0, 1, 2)
        const convertir = (coord) => {
          if (coord < -0.5) return 0;      // -1 -> 0
          if (coord > 0.5) return 2;       // 1 -> 2
          return 1;                        // 0 -> 1
        };
        
        let row, col;
        
        switch (cara) {
          case 'U': // Superior: mirando desde arriba
            row = 2 - convertir(coord1);  // Z invertido
            col = convertir(coord2);      // X normal
            break;
          case 'D': // Inferior: mirando desde abajo
            row = convertir(coord1);      // Z normal
            col = convertir(coord2);      // X normal
            break;
          case 'F': // Frontal: mirando de frente
            row = 2 - convertir(coord1);  // Y invertido
            col = convertir(coord2);      // X normal
            break;
          case 'B': // Trasera: mirando desde atr√°s
            row = 2 - convertir(coord1);  // Y invertido
            col = 2 - convertir(coord2);  // X invertido
            break;
          case 'L': // Izquierda: mirando desde la izquierda
            row = 2 - convertir(coord1);  // Y invertido
            col = 2 - convertir(coord2);  // Z invertido
            break;
          case 'R': // Derecha: mirando desde la derecha
            row = 2 - convertir(coord1);  // Y invertido
            col = convertir(coord2);      // Z normal
            break;
          default:
            row = 0;
            col = 0;
        }
        
        // Asegurar que los √≠ndices est√©n en rango v√°lido
        row = Math.max(0, Math.min(2, row));
        col = Math.max(0, Math.min(2, col));
        
        return [row, col];
      }

      // ‚Ü™ Cubie: peque√±a pieza que compone el cubo
      class Cubie extends THREE.Mesh {
        constructor(pos, size) {
          super();
          this.geometry = new THREE.BoxGeometry(size, size, size);

          const [x, y, z] = pos;
          this.originalPos = [x, y, z]; // Guardar posici√≥n original para referencia

          // Crear materiales para cada cara del cubo
          const materials = [];
          
          // BoxGeometry en Three.js tiene 6 caras, cada una con su propio material
          for (let i = 0; i < 6; i++) {
            const color = getColorForPosition(x, y, z, i);
            materials.push(new THREE.MeshLambertMaterial({ 
              color: color,
              transparent: false,
              opacity: 1.0
            }));
          }
          
          // Asignar el array de materiales directamente
          this.material = materials;

          // Agregar bordes para separar visualmente las piezas
          const edges = new THREE.EdgesGeometry(this.geometry);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
          const wireframe = new THREE.LineSegments(edges, lineMaterial);
          this.add(wireframe);

          this.position.set(
            x * (size + gap),
            y * (size + gap),
            z * (size + gap)
          );
          this.userData.cubePos = [...pos];
          
          // Habilitar sombras
          this.castShadow = true;
          this.receiveShadow = true;
        }

        // M√©todo para actualizar colores despu√©s de rotaciones
        updateColors() {
          const [x, y, z] = this.userData.cubePos;
          for (let i = 0; i < 6; i++) {
            const newColor = getColorForPosition(x, y, z, i);
            this.material[i].color.setHex(newColor);
          }
        }
      }

      // ‚Ü™ Crear cubo completo (omitir pieza central)
      const cubies = [];
      let cubieCount = 0;
      
      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -1; z <= 1; z++) {
            if (x === 0 && y === 0 && z === 0) continue; // Saltar la pieza central
            const c = new Cubie([x, y, z], cubieSize);
            scene.add(c);
            cubies.push(c);
            cubieCount++;
          }
        }
      }
      
      console.log(`‚úÖ Cubo creado con ${cubieCount} cubies (deber√≠a ser 26)`);
      
      // Verificar colores con tolerancia
      let greyFaceCount = 0;
      let externalGreyFaces = 0;
      
      cubies.forEach((cubie, index) => {
        const pos = cubie.userData.cubePos;
        cubie.material.forEach((material, faceIndex) => {
          if (material.color.getHex() === 0x222222) {
            // Verificar si deber√≠a ser una cara gris (interna) usando tolerancia
            const shouldBeGray = getColorForPosition(pos[0], pos[1], pos[2], faceIndex) === 0x222222;
            
            if (shouldBeGray) {
              greyFaceCount++;
            } else {
              externalGreyFaces++;
              console.warn(`‚ö†Ô∏è Cara externa gris detectada en cubie ${index}, cara ${faceIndex}, posici√≥n [${pos.join(', ')}]`);
            }
          }
        });
      });
      
      console.log(`Caras internas grises: ${greyFaceCount} (esto es normal)`);
      if (externalGreyFaces > 0) {
        console.warn(`‚ö†Ô∏è Caras externas grises incorrectas: ${externalGreyFaces}`);
      } else {
        console.log(`‚úÖ Todos los colores est√°n correctamente asignados`);
      }

      // Agregar informaci√≥n al debug
      window.CubeDebug = {
        cubies,
        epsilon,
        isClose,
        getColorForPosition,
        aplicarColoresDeMatriz,
        obtenerPosicionEnCara,
        COLOR_MAP,
        getCubieAt: (x, y, z) => cubies.find(c => 
          isClose(c.userData.cubePos[0], x) && 
          isClose(c.userData.cubePos[1], y) && 
          isClose(c.userData.cubePos[2], z)
        ),
        // ‚Ü™ Funci√≥n para inspeccionar colores aplicados desde matriz
        inspeccionarColoresMatriz: (matriz) => {
          console.log('üîç Inspeccionando aplicaci√≥n de colores desde matriz:');
          cubies.forEach((cubie, i) => {
            const [x, y, z] = cubie.userData.cubePos;
            console.log(`Cubie ${i} en posici√≥n [${x}, ${y}, ${z}]:`);
            
            cubie.material.forEach((material, faceIndex) => {
              const colorHex = material.color.getHexString().toUpperCase();
              const faces = ['R(+X)', 'L(-X)', 'U(+Y)', 'D(-Y)', 'F(+Z)', 'B(-Z)'];
              
              if (material.color.getHex() !== 0x222222) {
                console.log(`  Cara ${faces[faceIndex]}: #${colorHex}`);
              }
            });
          });
        },
        // ‚Ü™ Funci√≥n para probar la matriz de ejemplo
        probarMatrizEjemplo: () => {
          const matriz = generarCuboMezclado();
          aplicarColoresDeMatriz(matriz);
          console.log('üß™ Matriz de ejemplo aplicada al cubo 3D');
          return matriz;
        }
      };

      // ‚Ü™ Sistema de control paso a paso
      let moveSequence = [];
      let currentMoveIndex = -1;
      let isAnimating = false;
      let isPaused = false;
      let animationId = null;

      // ‚Ü™ Descripciones de movimientos
      const MOVE_DESCRIPTIONS = {
        'R': 'Gira la cara derecha en sentido horario',
        "R'": 'Gira la cara derecha en sentido antihorario',
        'R2': 'Gira la cara derecha 180 grados',
        'L': 'Gira la cara izquierda en sentido horario',
        "L'": 'Gira la cara izquierda en sentido antihorario',
        'L2': 'Gira la cara izquierda 180 grados',
        'U': 'Gira la cara superior en sentido horario',
        "U'": 'Gira la cara superior en sentido antihorario',
        'U2': 'Gira la cara superior 180 grados',
        'D': 'Gira la cara inferior en sentido horario',
        "D'": 'Gira la cara inferior en sentido antihorario',
        'D2': 'Gira la cara inferior 180 grados',
        'F': 'Gira la cara frontal en sentido horario',
        "F'": 'Gira la cara frontal en sentido antihorario',
        'F2': 'Gira la cara frontal 180 grados',
        'B': 'Gira la cara trasera en sentido horario',
        "B'": 'Gira la cara trasera en sentido antihorario',
        'B2': 'Gira la cara trasera 180 grados'
      };

      // ‚Ü™ Preparar animaci√≥n (versi√≥n paso a paso)
      function animateMovement(move, onComplete) {
        if (isAnimating) return;
        
        isAnimating = true;
        const { axis, layerFilter, angle } = parseMove(move);
        const group = new THREE.Group();
        const affected = cubies.filter((c) => layerFilter(c.userData.cubePos));

        // Usar grupos nativos en lugar de SceneUtils
        affected.forEach((c) => {
          scene.remove(c);
          group.add(c);
        });
        scene.add(group);

        const from = 0, to = angle * (Math.PI / 2);
        const start = performance.now();

        // Indicador visual de cara activa
        affected.forEach((c) => {
          c.material.forEach((mat) => (mat.transparent = true));
          c.material.forEach((mat) => (mat.opacity = 0.8));
        });

        function step(t) {
          if (isPaused) {
            animationId = requestAnimationFrame(step);
            return;
          }
          
          const progress = Math.min((t - start) / animationDuration, 1);
          const easedProgress = easeInOutCubic(progress);
          group.rotation[axis] = THREE.MathUtils.lerp(from, to, easedProgress);

          if (progress < 1) {
            animationId = requestAnimationFrame(step);
          } else {
            // Restaurar opacidad normal
            affected.forEach((c) => {
              c.material.forEach((mat) => (mat.opacity = 1.0));
              c.material.forEach((mat) => (mat.transparent = false));
            });

            // Actualizar posiciones y devolver cubies a la escena
            affected.forEach((c) => {
              const rotatedPos = new THREE.Vector3().copy(c.position);
              rotatedPos.applyAxisAngle(
                axis === "x" ? new THREE.Vector3(1, 0, 0) :
                axis === "y" ? new THREE.Vector3(0, 1, 0) :
                               new THREE.Vector3(0, 0, 1),
                to
              );

              // Actualizar posici√≥n l√≥gica con redondeo mejorado
              const newLogicalPos = [
                Math.round(rotatedPos.x / (cubieSize + gap)),
                Math.round(rotatedPos.y / (cubieSize + gap)),
                Math.round(rotatedPos.z / (cubieSize + gap)),
              ];
              
              c.userData.cubePos = newLogicalPos;
              
              // Actualizar colores despu√©s de la rotaci√≥n
              c.updateColors();

              group.remove(c);
              scene.add(c);
            });
            
            scene.remove(group);
            isAnimating = false;
            animationId = null;
            
            if (onComplete) onComplete();
          }
        }
        animationId = requestAnimationFrame(step);
      }

      function parseMove(move) {
        const face = move[0];
        const primed = move.includes("'");
        const double = move.includes("2");
        const angle = double ? 2 : 1;
        const dir = primed ? -1 : 1;
        const axisMap = { U: "y", D: "y", F: "z", B: "z", L: "x", R: "x" };
        
        // Usar tolerancia para filtrar capas
        const layerMap = {
          U: (cubie) => isClose(cubie[1], 1),
          D: (cubie) => isClose(cubie[1], -1),
          F: (cubie) => isClose(cubie[2], 1),
          B: (cubie) => isClose(cubie[2], -1),
          L: (cubie) => isClose(cubie[0], -1),
          R: (cubie) => isClose(cubie[0], 1),
        };
        
        return {
          axis: axisMap[face],
          layerFilter: layerMap[face],
          angle: angle * dir,
        };
      }

      // ‚Ü™ Funciones de control paso a paso
      function loadSequence(moves) {
        moveSequence = [...moves];
        currentMoveIndex = -1;
        updateUI();
        updateMoveDescription();
      }

      function nextMove() {
        if (isAnimating || currentMoveIndex >= moveSequence.length - 1) return;
        
        currentMoveIndex++;
        const move = moveSequence[currentMoveIndex];
        updateMoveDescription();
        
        animateMovement(move, () => {
          updateUI();
        });
      }

      function previousMove() {
        if (isAnimating || currentMoveIndex < 0) return;
        
        // Para retroceder, ejecutamos el movimiento inverso
        const move = moveSequence[currentMoveIndex];
        const inverseMove = getInverseMove(move);
        currentMoveIndex--;
        
        updateMoveDescription();
        
        animateMovement(inverseMove, () => {
          updateUI();
        });
      }

      function getInverseMove(move) {
        if (move.includes("'")) {
          return move.replace("'", "");
        } else if (move.includes("2")) {
          return move; // Los movimientos dobles son su propio inverso
        } else {
          return move + "'";
        }
      }

      function resetCube() {
        // Ejecutar todos los movimientos inversos desde la posici√≥n actual
        if (isAnimating) return;
        
        const inverseMoves = [];
        for (let i = currentMoveIndex; i >= 0; i--) {
          inverseMoves.push(getInverseMove(moveSequence[i]));
        }
        
        if (inverseMoves.length === 0) return;
        
        // Ejecutar todos los movimientos inversos en secuencia
        let index = 0;
        function executeNext() {
          if (index < inverseMoves.length) {
            animateMovement(inverseMoves[index], () => {
              index++;
              executeNext();
            });
          } else {
            currentMoveIndex = -1;
            updateUI();
            updateMoveDescription();
          }
        }
        executeNext();
      }

      function togglePause() {
        isPaused = !isPaused;
        document.getElementById('pause-btn').textContent = isPaused ? '‚ñ∂Ô∏è Continuar' : '‚è∏Ô∏è Pausar';
      }

      function updateUI() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const pauseBtn = document.getElementById('pause-btn');
        
        prevBtn.disabled = currentMoveIndex < 0 || isAnimating;
        nextBtn.disabled = currentMoveIndex >= moveSequence.length - 1 || isAnimating;
        pauseBtn.disabled = !isAnimating;
        
        // Actualizar informaci√≥n del paso
        const stepInfo = document.getElementById('step-info');
        if (moveSequence.length > 0) {
          stepInfo.textContent = `Paso ${currentMoveIndex + 1} de ${moveSequence.length}`;
        } else {
          stepInfo.textContent = 'Listo para comenzar';
        }
      }

      function updateMoveDescription() {
        const moveDesc = document.getElementById('move-description');
        if (currentMoveIndex >= 0 && currentMoveIndex < moveSequence.length) {
          const move = moveSequence[currentMoveIndex];
          const description = MOVE_DESCRIPTIONS[move] || `Movimiento: ${move}`;
          moveDesc.textContent = `${move}: ${description}`;
        } else if (moveSequence.length > 0) {
          const nextMove = moveSequence[currentMoveIndex + 1];
          if (nextMove) {
            const description = MOVE_DESCRIPTIONS[nextMove] || `Movimiento: ${nextMove}`;
            moveDesc.textContent = `Siguiente: ${nextMove} - ${description}`;
          } else {
            moveDesc.textContent = 'Secuencia completada';
          }
        } else {
          moveDesc.textContent = 'Presiona "Cargar Secuencia" para comenzar';
        }
      }

      // ‚Ü™ Funci√≥n para configurar par√°metros del cubo
      function configureCube(options = {}) {
        if (options.animationSpeed) animationDuration = options.animationSpeed;
        if (options.gap !== undefined) gap = options.gap;
      }

      // ‚Ü™ Exponer funciones globales para uso externo
      window.RubikCube = {
        loadSequence,
        nextMove,
        previousMove,
        resetCube,
        togglePause,
        configureCube,
        setAnimationSpeed: (speed) => { animationDuration = speed; },
        isAnimating: () => isAnimating,
        getCurrentStep: () => currentMoveIndex + 1,
        getTotalSteps: () => moveSequence.length,
        // Nuevas funciones
        resolverDesdeServidor: resolverCuboDesdeServidor,
        conectarServidor: conectarConServidor,
        probarConexion: probarConexion,
        generarCuboMezclado: generarCuboMezclado
      };

      // ‚Ü™ Render loop
      function render() {
        requestAnimationFrame(render);
        renderer.render(scene, camera);
      }
      render();

      // üîß Event listeners para controles
      document.getElementById('next-btn').addEventListener('click', nextMove);
      document.getElementById('prev-btn').addEventListener('click', previousMove);
      document.getElementById('reset-btn').addEventListener('click', resetCube);
      document.getElementById('pause-btn').addEventListener('click', togglePause);
      
      document.getElementById('load-sequence-btn').addEventListener('click', () => {
        const sequences = [
          ["R", "U'", "F", "L2", "D"],
          ["R", "U", "R'", "F", "R", "F'"],
          ["F", "R", "U'", "R'", "U'", "R", "U", "R'", "F'"],
          ["R", "U", "R'", "U", "R", "U2", "R'"]
        ];
        const randomSequence = sequences[Math.floor(Math.random() * sequences.length)];
        loadSequence(randomSequence);
      });

      // Nuevo event listener para resolver desde servidor
      document.getElementById('solve-server-btn').addEventListener('click', resolverCuboDesdeServidor);

      // Control de velocidad
      const speedSlider = document.getElementById('speed-slider');
      const speedValue = document.getElementById('speed-value');
      
      speedSlider.addEventListener('input', (e) => {
        animationDuration = parseInt(e.target.value);
        speedValue.textContent = `${animationDuration}ms`;
      });

      // üîß Controles de teclado mejorados:
      window.addEventListener("keydown", (e) => {
        if (e.key === " ") {
          e.preventDefault();
          if (moveSequence.length === 0) {
            loadSequence(["R", "U'", "F", "L2", "D"]);
          } else {
            nextMove();
          }
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          nextMove();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          previousMove();
        } else if (e.key === "Enter") {
          e.preventDefault();
          loadSequence(["R", "U", "R'", "F", "R", "F'", "U'", "R'", "F", "R", "F'"]);
        } else if (e.key === "Escape") {
          e.preventDefault();
          resetCube();
        } else if (e.key === "p" || e.key === "P") {
          e.preventDefault();
          togglePause();
        }
      });

      // Inicializar UI
      updateUI();
      updateMoveDescription();

      // ‚Ü™ Funci√≥n para conectar con el servidor Python
      async function conectarConServidor(matrizCubo) {
        try {
          console.log('üì° Enviando cubo al servidor...', matrizCubo);
          
          const response = await fetch('http://localhost:5000/solve', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ matriz: matrizCubo })
          });

          if (!response.ok) {
            throw new Error(`Error del servidor: ${response.status}`);
          }

          const data = await response.json();
          console.log('‚úÖ Respuesta del servidor:', data);

          if (data.status === 'success' && data.movimientos) {
            return data.movimientos;
          } else {
            throw new Error(data.message || 'Error desconocido del servidor');
          }
        } catch (error) {
          console.error('‚ùå Error al conectar con el servidor:', error);
          throw error;
        }
      }

      // ‚Ü™ Funci√≥n para probar la conexi√≥n con el servidor
      async function probarConexion() {
        try {
          const response = await fetch('http://localhost:5000/health');
          const data = await response.json();
          console.log('üè• Estado del servidor:', data);
          return true;
        } catch (error) {
          console.error('‚ùå Servidor no disponible:', error);
          return false;
        }
      }

      // ‚Ü™ Funci√≥n para generar una matriz de cubo mezclado m√°s realista
      function generarCuboMezclado() {
        // Crear un cubo resuelto primero
        const cuboResuelto = [
          [['W', 'W', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W']], // Superior (blanco)
          [['G', 'G', 'G'], ['G', 'G', 'G'], ['G', 'G', 'G']], // Frontal (verde)
          [['Y', 'Y', 'Y'], ['Y', 'Y', 'Y'], ['Y', 'Y', 'Y']], // Inferior (amarillo)
          [['B', 'B', 'B'], ['B', 'B', 'B'], ['B', 'B', 'B']], // Trasera (azul)
          [['O', 'O', 'O'], ['O', 'O', 'O'], ['O', 'O', 'O']], // Izquierda (naranja)
          [['R', 'R', 'R'], ['R', 'R', 'R'], ['R', 'R', 'R']]  // Derecha (rojo)
        ];
        
        // Mezclar algunos colores para simular cubo mezclado
        const cuboMezclado = [
          [['W', 'R', 'G'], ['Y', 'W', 'B'], ['O', 'Y', 'R']], // Superior mezclado
          [['G', 'R', 'W'], ['O', 'G', 'Y'], ['B', 'O', 'Y']], // Frontal mezclado
          [['B', 'G', 'W'], ['R', 'Y', 'G'], ['O', 'B', 'R']], // Inferior mezclado
          [['Y', 'B', 'O'], ['G', 'B', 'R'], ['W', 'G', 'B']], // Trasera mezclado
          [['R', 'W', 'Y'], ['B', 'O', 'O'], ['G', 'Y', 'W']], // Izquierda mezclado
          [['O', 'G', 'B'], ['W', 'R', 'R'], ['Y', 'R', 'O']]  // Derecha mezclado
        ];
        
        return cuboMezclado;
      }

      // ‚Ü™ Funci√≥n principal para resolver cubo desde servidor
      async function resolverCuboDesdeServidor() {
        try {
          // Mostrar estado de carga
          mostrarEstado('üîÑ Conectando con servidor...', 'info');
          
          // Verificar conexi√≥n con servidor
          const servidorDisponible = await probarConexion();
          if (!servidorDisponible) {
            mostrarEstado('‚ùå Servidor no disponible', 'error');
            alert('‚ùå No se puede conectar con el servidor. Aseg√∫rate de que server.py est√© ejecut√°ndose.');
            return;
          }

          mostrarEstado('üß† Resolviendo cubo...', 'info');
          
          // Generar o obtener matriz del cubo
          const matrizCubo = generarCuboMezclado();
          
          // üé® APLICAR COLORES DE LA MATRIZ AL CUBO 3D
          aplicarColoresDeMatriz(matrizCubo);
          
          // Enviar al servidor y obtener soluci√≥n
          const movimientos = await conectarConServidor(matrizCubo);
          
          // Cargar la secuencia en el cubo 3D
          loadSequence(movimientos);
          
          // Mostrar informaci√≥n al usuario
          mostrarEstado(`‚úÖ Soluci√≥n cargada: ${movimientos.length} pasos`, 'info');
          document.getElementById('move-description').textContent = 'Presiona "Siguiente" para comenzar la soluci√≥n';
          
          console.log('üéØ Secuencia de soluci√≥n cargada:', movimientos);
          console.log('üé® Colores aplicados desde matriz del servidor');
          
        } catch (error) {
          console.error('‚ùå Error al resolver cubo:', error);
          mostrarEstado(`‚ùå Error: ${error.message}`, 'error');
          alert(`Error: ${error.message}`);
        }
      }

      // Probar conexi√≥n y resolver cubo al cargar (descomentar para habilitar)
      // window.addEventListener('load', () => {
      //   resolverCuboDesdeServidor();
      // });
      
      // ‚Ü™ Funci√≥n para mostrar estado visual
      function mostrarEstado(mensaje, tipo = 'info') {
        const stepInfo = document.getElementById('step-info');
        const colores = {
          'info': '#4CAF50',
          'error': '#f44336',
          'warning': '#ff9800',
          'loading': '#2196F3'
        };
        
        stepInfo.style.color = colores[tipo] || colores.info;
        stepInfo.textContent = mensaje;
        
        // Restaurar color despu√©s de 3 segundos
        setTimeout(() => {
          stepInfo.style.color = '#fff';
        }, 3000);
      }
    </script>
  </body>
</html>
